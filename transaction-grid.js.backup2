// Transaction Grid using AG Grid

const TransactionGrid = {
    gridApi: null,
    transactions: [],

    initialize(containerId) {
        const container = document.getElementById(containerId);

        const gridOptions = {
            columnDefs: this.getColumnDefs(),
            defaultColDef: {
                sortable: true,
                filter: true,
                resizable: true,
                editable: false,
                floatingFilter: true, // Enable floating filters for quick search
                filterParams: {
                    buttons: ['reset', 'apply'],
                    debounceMs: 200
                }
            },
            rowData: [],
            animateRows: true,
            enableCellChangeFlash: true,
            enableRangeSelection: true, // Allow selecting ranges
            enableFillHandle: true, // Allow dragging to fill cells
            suppressRowClickSelection: false,
            rowSelection: 'multiple',
            onCellValueChanged: this.onCellValueChanged.bind(this),
            onGridReady: (params) => {
                this.gridApi = params.api;
                this.columnApi = params.columnApi;
                this.gridApi.sizeColumnsToFit();

                // Add custom grid toolbar
                this.addGridToolbar(container);
            },
            getRowStyle: (params) => {
                if (params.data.status === 'unmatched') {
                    return { background: 'rgba(239, 68, 68, 0.1)' };
                } else if (params.data.status === 'matched') {
                    return { background: 'rgba(34, 197, 94, 0.1)' };
                } else if (params.data.status === 'manual') {
                    return { background: 'rgba(59, 130, 246, 0.1)' };
                }
                return null;
            }
        };

        new agGrid.Grid(container, gridOptions);
    },

    addGridToolbar(container) {
        // Create toolbar div before grid
        const toolbar = document.createElement('div');
        toolbar.className = 'grid-toolbar';
        toolbar.innerHTML = `
            <div class="toolbar-left">
                <input type="text" id="gridQuickFilter" placeholder="Quick search..." class="toolbar-search">
            </div>
            <div class="toolbar-right">
                <button id="gridColumnToggle" class="btn-icon" title="Show/Hide Columns">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7"></rect>
                        <rect x="14" y="3" width="7" height="7"></rect>
                        <rect x="14" y="14" width="7" height="7"></rect>
                        <rect x="3" y="14" width="7" height="7"></rect>
                    </svg>
                </button>
                <button id="gridExportCsv" class="btn-icon" title="Export to CSV">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                </button>
            </div>
        `;

        container.parentElement.insertBefore(toolbar, container);

        // Wire up toolbar events
        const quickFilter = document.getElementById('gridQuickFilter');
        if (quickFilter) {
            quickFilter.addEventListener('input', (e) => {
                this.gridApi.setQuickFilter(e.target.value);
            });
        }

        const columnToggle = document.getElementById('gridColumnToggle');
        if (columnToggle) {
            columnToggle.addEventListener('click', () => {
                this.showColumnManager();
            });
        }

        const exportBtn = document.getElementById('gridExportCsv');
        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                this.exportToCsv();
            });
        }
    },

    showColumnManager() {
        const columns = this.columnApi.getAllColumns();
        const columnStates = columns.map(col => ({
            colId: col.getColId(),
            headerName: col.getColDef().headerName,
            visible: col.isVisible()
        }));

        // Create modal for column management
        const modal = document.createElement('div');
        modal.className = 'modal active';
        modal.id = 'columnManagerModal';
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 400px;">
                <div class="modal-header">
                    <h2>Manage Columns</h2>
                    <button class="modal-close" id="closeColumnManager">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="column-list">
                        ${columnStates.map(col => `
                            <div class="column-item">
                                <label>
                                    <input type="checkbox" data-col-id="${col.colId}" ${col.visible ? 'checked' : ''}>
                                    ${col.headerName}
                                </label>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(modal);

        // Handle checkbox changes
        modal.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                this.columnApi.setColumnVisible(e.target.dataset.colId, e.target.checked);
            });
        });

        // Close button
        modal.querySelector('#closeColumnManager').addEventListener('click', () => {
            modal.remove();
        });

        // Click outside to close
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
    },

    getColumnDefs() {
        const accounts = AccountAllocator.getAllAccounts();
        const accountOptions = accounts.map(a => a.fullName);

        return [
            {
                headerName: 'Ref #',
                field: 'ref',
                width: 120,
                pinned: 'left'
            },
            {
                headerName: 'Date',
                field: 'date',
                width: 120,
                valueFormatter: (params) => {
                    return Utils.formatDate(params.value, 'MM/DD/YYYY');
                }
            },
            {
                headerName: 'Payee',
                field: 'payee',
                width: 250,
                tooltipField: 'payee'
            },
            {
                headerName: 'Vendor',
                field: 'vendor',
                width: 180,
                editable: true,
                cellStyle: { background: 'rgba(99, 102, 241, 0.05)' }
            },
            {
                headerName: 'Debit',
                field: 'debits',
                width: 120,
                type: 'numericColumn',
                valueFormatter: (params) => {
                    return params.value > 0 ? Utils.formatCurrency(params.value) : '';
                },
                cellStyle: (params) => {
                    if (params.value > 0) {
                        return { color: '#ef4444', fontWeight: '500' };
                    }
                    return null;
                }
            },
            {
                headerName: 'Credit',
                field: 'amount',
                width: 120,
                type: 'numericColumn',
                valueFormatter: (params) => {
                    return params.value > 0 ? Utils.formatCurrency(params.value) : '';
                },
                cellStyle: (params) => {
                    if (params.value > 0) {
                        return { color: '#22c55e', fontWeight: '500' };
                    }
                    return null;
                }
            },
            {
                headerName: 'Balance',
                field: 'balance',
                width: 120,
                type: 'numericColumn',
                valueFormatter: (params) => {
                    return Utils.formatCurrency(params.value);
                }
            },
            {
                headerName: 'Account #',
                field: 'allocatedAccount',
                width: 120,
                editable: false,
                sortable: true,
                filter: true
            },
            {
                headerName: 'Account',
                field: 'allocatedAccountName',
                width: 300,
                editable: true,
                cellEditor: 'agSelectCellEditor',
                cellEditorParams: {
                    values: accountOptions
                },
                cellStyle: { background: 'rgba(99, 102, 241, 0.05)' },
                tooltipField: 'allocatedAccountName'
            },
            {
                headerName: 'Status',
                field: 'status',
                width: 120,
                sortable: true,
                filter: true,
                cellRenderer: (params) => {
                    const statusMap = {
                        'matched': { icon: '✓', color: '#22c55e', text: 'Matched' },
                        'unmatched': { icon: '!', color: '#ef4444', text: 'Unmatched' },
                        'manual': { icon: '✎', color: '#3b82f6', text: 'Manual' },
                        'reviewed': { icon: '✓✓', color: '#8b5cf6', text: 'Reviewed' }
                    };

                    const status = statusMap[params.value] || statusMap['unmatched'];
                    return `<span style="color: ${status.color}; font-weight: 500;">${status.icon} ${status.text}</span>`;
                }
            }
        ];
    },

    loadTransactions(transactions) {
        this.transactions = transactions;
        if (this.gridApi) {
            this.gridApi.setRowData(transactions);
            this.gridApi.sizeColumnsToFit();
        }
    },

    onCellValueChanged(event) {
        const transaction = event.data;
        const field = event.colDef.field;

        // Handle account selection
        if (field === 'allocatedAccountName') {
            const accountName = event.newValue;
            const account = AccountAllocator.getAllAccounts().find(a =>
                a.fullName === accountName
            );

            if (account) {
                transaction.allocatedAccount = account.code;
                transaction.allocatedAccountName = account.name;
                transaction.status = 'manual';

                // Learn from this manual categorization
                VendorMatcher.learnFromTransaction(transaction);

                // Refresh the row to update status
                this.gridApi.refreshCells({ rowNodes: [event.node], force: true });

                // Update statistics
                App.updateStatistics();
            }
        }

        // Handle vendor name change
        if (field === 'vendor') {
            transaction.vendor = event.newValue;
            transaction.status = 'manual';

            // Refresh the row
            this.gridApi.refreshCells({ rowNodes: [event.node], force: true });
        }

        // Handle category or notes change
        if (field === 'category' || field === 'notes') {
            // Just update the transaction
            this.gridApi.refreshCells({ rowNodes: [event.node], force: true });
        }

        // Save to localStorage
        Storage.saveTransactions(this.transactions);
    },

    getTransactions() {
        return this.transactions;
    },

    updateTransaction(transactionId, updates) {
        const transaction = this.transactions.find(t => t.id === transactionId);
        if (transaction) {
            Object.assign(transaction, updates);
            this.gridApi.applyTransaction({ update: [transaction] });
            Storage.saveTransactions(this.transactions);
        }
    },

    exportToCsv() {
        if (this.gridApi) {
            this.gridApi.exportDataAsCsv({
                fileName: `transactions_${ExcelExporter.getDateString()}.csv`
            });
        }
    }
};

// Vendor Dictionary Grid
const VendorGrid = {
    gridApi: null,

    initialize(containerId) {
        const container = document.getElementById(containerId);

        const gridOptions = {
            columnDefs: this.getColumnDefs(),
            defaultColDef: {
                sortable: true,
                filter: true,
                resizable: true,
                editable: true
            },
            rowData: [],
            animateRows: true,
            onCellValueChanged: this.onCellValueChanged.bind(this),
            onGridReady: (params) => {
                this.gridApi = params.api;
                this.loadVendors();
            }
        };

        new agGrid.Grid(container, gridOptions);
    },

    getColumnDefs() {
        const accounts = AccountAllocator.getAllAccounts();
        const accountOptions = accounts.map(a => a.fullName);
        const accountCodes = accounts.map(a => a.code);

        return [
            {
                headerName: 'Vendor Name',
                field: 'name',
                width: 250,
                pinned: 'left',
                editable: true,  // Now editable!
                cellStyle: { background: 'rgba(99, 102, 241, 0.05)' }
            },
            {
                headerName: 'Account #',
                field: 'defaultAccount',
                width: 120,
                editable: true,  // Now editable!
                cellEditor: 'agSelectCellEditor',
                cellEditorParams: {
                    values: accountCodes
                },
                sortable: true,
                filter: true,
                valueFormatter: (params) => {
                    return params.value || '9970';
                },
                cellStyle: { background: 'rgba(99, 102, 241, 0.05)' }
            },
            {
                headerName: 'Account Name',
                field: 'defaultAccountName',
                width: 250,
                editable: true,
                cellEditor: 'agSelectCellEditor',
                cellEditorParams: {
                    values: accountOptions
                },
                cellStyle: { background: 'rgba(99, 102, 241, 0.05)' }
            },
            {
                headerName: 'Category',
                field: 'category',
                width: 150,
                editable: true,
                cellStyle: { background: 'rgba(99, 102, 241, 0.05)' }
            },
            {
                headerName: 'Match Count',
                field: 'matchCount',
                width: 120,
                editable: false,
                type: 'numericColumn'
            },
            {
                headerName: 'Notes',
                field: 'notes',
                width: 200,
                editable: true,
                cellStyle: { background: 'rgba(99, 102, 241, 0.05)' }
            },
            {
                headerName: 'Actions',
                width: 120,
                editable: false,
                cellRenderer: (params) => {
                    return '<button class="delete-vendor-btn" style="padding: 4px 8px; cursor: pointer;">Delete</button>';
                },
                onCellClicked: (params) => {
                    if (params.event.target.classList.contains('delete-vendor-btn')) {
                        this.deleteVendor(params.data.id);
                    }
                }
            }
        ];
        filter: true,
            cellRenderer: (params) => {
                const statusMap = {
                    'matched': { icon: '✓', color: '#22c55e', text: 'Matched' },
                    'unmatched': { icon: '!', color: '#ef4444', text: 'Unmatched' },
                    'manual': { icon: '✎', color: '#3b82f6', text: 'Manual' },
                    'reviewed': { icon: '✓✓', color: '#8b5cf6', text: 'Reviewed' }
                };

                const status = statusMap[params.value] || statusMap['unmatched'];
                return `<span style="color: ${status.color}; font-weight: 500;">${status.icon} ${status.text}</span>`;
            }
    }
        ];
    },

loadTransactions(transactions) {
    this.transactions = transactions;
    if (this.gridApi) {
        this.gridApi.setRowData(transactions);
        this.gridApi.sizeColumnsToFit();
    }
},

onCellValueChanged(event) {
    const transaction = event.data;
    const field = event.colDef.field;

    // Handle account selection
    if (field === 'allocatedAccountName') {
        const accountName = event.newValue;
        const account = AccountAllocator.getAllAccounts().find(a =>
            a.fullName === accountName
        );

        if (account) {
            transaction.allocatedAccount = account.code;
            transaction.allocatedAccountName = account.name;
            transaction.status = 'manual';

            // Learn from this manual categorization
            VendorMatcher.learnFromTransaction(transaction);

            // Refresh the row to update status
            this.gridApi.refreshCells({ rowNodes: [event.node], force: true });

            // Update statistics
            App.updateStatistics();
        }
    }

    // Handle vendor name change
    if (field === 'vendor') {
        transaction.vendor = event.newValue;
        transaction.status = 'manual';

        // Refresh the row
        this.gridApi.refreshCells({ rowNodes: [event.node], force: true });
    }

    // Handle category or notes change
    if (field === 'category' || field === 'notes') {
        // Just update the transaction
        this.gridApi.refreshCells({ rowNodes: [event.node], force: true });
    }

    // Save to localStorage
    Storage.saveTransactions(this.transactions);
},

getTransactions() {
    return this.transactions;
},

updateTransaction(transactionId, updates) {
    const transaction = this.transactions.find(t => t.id === transactionId);
    if (transaction) {
        Object.assign(transaction, updates);
        this.gridApi.applyTransaction({ update: [transaction] });
        Storage.saveTransactions(this.transactions);
    }
},

exportToCsv() {
    if (this.gridApi) {
        this.gridApi.exportDataAsCsv({
            fileName: `transactions_${ExcelExporter.getDateString()}.csv`
        });
    }
}
};

// Vendor Dictionary Grid
const VendorGrid = {
    gridApi: null,

    initialize(containerId) {
        const container = document.getElementById(containerId);

        const gridOptions = {
            columnDefs: this.getColumnDefs(),
            defaultColDef: {
                sortable: true,
                filter: true,
                resizable: true,
                editable: true
            },
            rowData: [],
            animateRows: true,
            onCellValueChanged: this.onCellValueChanged.bind(this),
            onGridReady: (params) => {
                this.gridApi = params.api;
                this.loadVendors();
            }
        };

        new agGrid.Grid(container, gridOptions);
    },

    getColumnDefs() {
        const accounts = AccountAllocator.getAllAccounts();
        const accountOptions = accounts.map(a => a.fullName);
        const accountCodes = accounts.map(a => a.code);

        return [
            {
                headerName: 'Vendor Name',
                field: 'name',
                width: 250,
                pinned: 'left',
                editable: true,  // Now editable!
                cellStyle: { background: 'rgba(99, 102, 241, 0.05)' }
            },
            {
                headerName: 'Account #',
                field: 'defaultAccount',
                width: 120,
                editable: true,  // Now editable!
                cellEditor: 'agSelectCellEditor',
                cellEditorParams: {
                    values: accountCodes
                },
                sortable: true,
                filter: true,
                valueFormatter: (params) => {
                    return params.value || '9970';
                },
                cellStyle: { background: 'rgba(99, 102, 241, 0.05)' }
            },
            {
                headerName: 'Account Name',
                field: 'defaultAccountName',
                width: 250,
                editable: true,
                cellEditor: 'agSelectCellEditor',
                cellEditorParams: {
                    values: accountOptions
                },
                cellStyle: { background: 'rgba(99, 102, 241, 0.05)' }
            },
            {
                headerName: 'Category',
                field: 'category',
                width: 150,
                editable: true,
                cellStyle: { background: 'rgba(99, 102, 241, 0.05)' }
            },
            {
                headerName: 'Match Count',
                field: 'matchCount',
                width: 120,
                editable: false,
                type: 'numericColumn'
            },
            {
                headerName: 'Notes',
                field: 'notes',
                width: 200,
                editable: true,
                cellStyle: { background: 'rgba(99, 102, 241, 0.05)' }
            },
            {
                headerName: 'Actions',
                width: 120,
                editable: false,
                cellRenderer: (params) => {
                    return '<button class="delete-vendor-btn" style="padding: 4px 8px; cursor: pointer;">Delete</button>';
                },
                onCellClicked: (params) => {
                    if (params.event.target.classList.contains('delete-vendor-btn')) {
                        this.deleteVendor(params.data.id);
                    }
                }
            }
        ];
    },

    loadVendors() {
        const vendors = VendorMatcher.getAllVendors();
        if (this.gridApi) {
            this.gridApi.setRowData(vendors);
        }
    },

    onCellValueChanged(event) {
        const vendor = event.data;
        const field = event.colDef.field;

        // Handle account# selection - auto-fill account name
        if (field === 'defaultAccount') {
            const accountCode = event.newValue;
            const account = AccountAllocator.getAllAccounts().find(a =>
                a.code === accountCode
            );

            if (account) {
                vendor.defaultAccount = account.code;
                vendor.defaultAccountName = account.name;
                // Refresh row to show updated account name
                this.gridApi.refreshCells({ rowNodes: [event.node], force: true });
            }
        }

        // Handle account name selection - also update account#
        if (field === 'defaultAccountName') {
            const accountName = event.newValue;
            const account = AccountAllocator.getAllAccounts().find(a =>
                a.fullName === accountName
            );

            if (account) {
                vendor.defaultAccount = account.code;
                vendor.defaultAccountName = account.name;
                // Refresh row to show updated account#
                this.gridApi.refreshCells({ rowNodes: [event.node], force: true });
            }
        }

        // Update vendor
        VendorMatcher.updateVendor(vendor.id, vendor);
    },

    deleteVendor(vendorId) {
        if (confirm('Are you sure you want to delete this vendor?')) {
            VendorMatcher.deleteVendor(vendorId);
            this.loadVendors();
        }
    },

    addVendor(vendorData) {
        VendorMatcher.addVendor(vendorData);
        this.loadVendors();
    }
};
