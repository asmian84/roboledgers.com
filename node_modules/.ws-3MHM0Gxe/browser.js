'use strict';

module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};
ose');
const _ended = Symbol('_ended');
const _fd = Symbol('_fd');
const _finished = Symbol('_finished');
const _flags = Symbol('_flags');
const _flush = Symbol('_flush');
const _handleChunk = Symbol('_handleChunk');
const _makeBuf = Symbol('_makeBuf');
const _mode = Symbol('_mode');
const _needDrain = Symbol('_needDrain');
const _onerror = Symbol('_onerror');
const _onopen = Symbol('_onopen');
const _onread = Symbol('_onread');
const _onwrite = Symbol('_onwrite');
const _open = Symbol('_open');
const _path = Symbol('_path');
const _pos = Symbol('_pos');
const _queue = Symbol('_queue');
const _read = Symbol('_read');
const _readSize = Symbol('_readSize');
const _reading = Symbol('_reading');
const _remain = Symbol('_remain');
const _size = Symbol('_size');
const _write = Symbol('_write');
const _writing = Symbol('_writing');
const _defaultFlag = Symbol('_defaultFlag');
const _errored = Symbol('_errored');
export class ReadStream extends Minipass {
    [_errored] = false;
    [_fd];
    [_path];
    [_readSize];
    [_reading] = false;
    [_size];
    [_remain];
    [_autoClose];
    constructor(path, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path !== 'string') {
            throw new TypeError('path must be a string');
        }
        this[_errored] = false;
        this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined;
        this[_path] = path;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] =
            typeof opt.autoClose === 'boolean' ? opt.autoClose : true;
        if (typeof this[_fd] === 'number') {
            this[_read]();
        }
        else {
            this[_open]();
        }
    }
    get fd() {
        return this[_fd];
    }
    get path() {
        return this[_path];
    }
    //@ts-ignore
    write() {
        throw new TypeError('this is a readable stream');
    }
    //@ts-ignore
    end() {
        throw new TypeError('this is a readable stream');
    }
    [_open]() {
        fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
        if (er) {
            this[_onerror](er);
        }
        else {
            this[_fd] = fd;
            this.emit('open', fd);
            this[_read]();
        }
    }
    [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
    [_read]() {
        if (!this[_reading]) {
            this[_reading] = true;
            const buf = this[_makeBuf]();
            /* c8 ignore start */
            if (buf.length === 0) {
                return process.nextTick(() => this[_onread](null, 0, buf));
            }
            /* c8 ignore stop */
            fs.read(this[_fd], buf, 0, buf.length, null, (er, br, b) => this[_onread](er, br, b));
        }
    }
    [_onread](er, br, buf) {
        this[_reading] = false;
        if (er) {
            this[_onerror](er);
        }
        else if (this[_handleChunk](br, buf)) {
            this[_read]();
        }
    }
    [_close]() {
        if (this[_autoClose] && typeof this[_fd] === 'number') {
            const fd = this[_fd];
            this[_fd] = undefined;
            fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'));
        }
    }
    [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit('error', er);
    }
    [_handleChunk](br, buf) {
        let ret = false;
        // no effect if infinite
        this[_remain] -= br;
        if (br > 0) {
            ret = super.write(br < buf.length ? buf.subarray(0, br) : buf);
        }
        if (br === 0 || this[_remain] <= 0) {
            ret = false;
            this[_close]();
            super.end();
        }
        return ret;
    }
    emit(ev, ...args) {
        switch (ev) {
            case 'prefinish':
            case 'finish':
                return false;
            case 'drain':
                if (typeof this[_fd] === 'number') {
                    this[_read]();
                }
                return false;
            case 'error':
                if (this[_errored]) {
                    return false;
                }
                this[_errored] = true;
                return super.emit(ev, ...args);
            default:
                return super.emit(ev, ...args);
        }
    }
}
export class ReadStreamSync extends ReadStream {
    [_open]() {
        let threw = true;
        try {
            this[_onopen](null, fs.openSync(this[_path], 'r'));
            threw = false;
        }
        finally {
            if (threw) {
                this[_close]();
            }
        }
    }
    [_read]() {
        let threw = true;
        try {
            if (!this[_reading]) {
                this[_reading] = true;
                do {
                    const buf = this[_makeBuf]();
                    /* c8 ignore start */
                    const br = buf.length === 0
                        ? 0
                        : fs.readSync(this[_fd], buf, 0, buf.length, null);
                    /* c8 ignore stop */
                    if (!this[_handleChunk](br, buf)) {
                        break;
                    }
                } while (true);
                this[_reading] = false;
            }
            threw = false;
        }
        finally {
            if (threw) {
                this[_close]();
            }
        }
    }
    [_close]() {
        if (this[_autoClose] && typeof this[_fd] === 'number') {
            const fd = this[_fd];
            this[_fd] = undefined;
            fs.closeSync(fd);
            this.emit('close');
        }
    }
}
export class WriteStream extends EE {
    readable = false;
    writable = true;
    [_errored] = false;
    [_writing] = false;
    [_ended] = false;
    [_queue] = [];
    [_needDrain] = false;
    [_path];
    [_mode];
    [_autoClose];
    [_fd];
    [_defaultFlag];
    [_flags];
    [_finished] = false;
    [_pos];
    constructor(path, opt) {
        opt = opt || {};
        super(opt);
        this[_path] = path;
        this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined;
        this[_mode] = opt.mode === undefined ? 0o666 : opt.mode;
        this[_pos] = typeof opt.start === 'number' ? opt.start : undefined;
        this[_autoClose] =
            typeof opt.autoClose === 'boolean' ? opt.autoClose : true;
        // truncating makes no sense when writing into the middle
        const defaultFlag = this[_pos] !== undefined ? 'r+' : 'w';
        this[_defaultFlag] = opt.flags === undefined;
        this[_flags] = opt.flags === undefined ? defaultFlag : opt.flags;
        if (this[_fd] === undefined) {
            this[_open]();
        }
    }
    emit(ev, ...args) {
        if (ev === 'error') {
            if (this[_errored]) {
                return false;
            }
            this[_errored] = true;
        }
        return super.emit(ev, ...args);
    }
    get fd() {
        return this[_fd];
    }
    get path() {
        return this[_path];
    }
    [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit('error', er);
    }
    [_open]() {
        fs.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
        if (this[_defaultFlag] &&
            this[_flags] === 'r+' &&
            er &&
            er.code === 'ENOENT') {
            this[_flags] = 'w';
            this[_open]();
        }
        else if (er) {
            this[_onerror](er);
        }
        else {
            this[_fd] = fd;
            this.emit('open', fd);
            if (!this[_writing]) {
                this[_flush]();
            }
        }
    }
    end(buf, enc) {
        if (buf) {
            //@ts-ignore
            this.write(buf, enc);
        }
        this[_ended] = true;
        // synthetic after-write logic, where drain/finish live
        if (!this[_writing] &&
            !this[_queue].length &&
            typeof this[_fd] === 'number') {
            this[_onwrite](null, 0);
        }
        return this;
    }
    write(buf, enc) {
        if (typeof buf === 'string') {
            buf = Buffer.from(buf, enc);
        }
        if (this[_ended]) {
            this.emit('error', new Error('write() after end()'));
            return false;
        }
        if (this[_fd] === undefined || this[_writing] || this[_queue].length) {
            this[_queue].push(buf);
            this[_needDrain] = true;
            return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
    }
    [_write](buf) {
        fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
    [_onwrite](er, bw) {
        if (er) {
            this[_onerror](er);
        }
        else {
            if (this[_pos] !== undefined && typeof bw === 'number') {
                this[_pos] += bw;
            }
            if (this[_queue].length) {
                this[_flush]();
            }
            else {
                this[_writing] = false;
                if (this[_ended] && !this[_finished]) {
                    this[_finished] = true;
                    this[_close]();
                    this.emit('finish');
                }
                else if (this[_needDrain]) {
                    this[_needDrain] = false;
                    this.emit('drain');
                }
            }
        }
    }
    [_flush]() {
        if (this[_queue].length === 0) {
            if (this[_ended]) {
                this[_onwrite](null, 0);
            }
        }
        else if (this[_queue].length === 1) {
            this[_write](this[_queue].pop());
        }
        else {
            const iovec = this[_queue];
            this[_queue] = [];
            writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
        }
    }
    [_close]() {
        if (this[_autoClose] && typeof this[_fd] === 'number') {
            const fd = this[_fd];
            this[_fd] = undefined;
            fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'));
        }
    }
}
export class WriteStreamSync extends WriteStream {
    [_open]() {
        let fd;
        // only wrap in a try{} block if we know we'll retry, to avoid
        // the rethrow obscuring the error's source frame in most cases.
        if (this[_defaultFlag] && this[_flags] === 'r+') {
            try {
                fd = fs.openSync(this[_path], this[_flags], this[_mode]);
            }
            catch (er) {
                if (er?.code === 'ENOENT') {
                    this[_flags] = 'w';
                    return this[_open]();
                }
                else {
                    throw er;
                }
            }
        }
        else {
            fd = fs.openSync(this[_path], this[_flags], this[_mode]);
        }
        this[_onopen](null, fd);
    }
    [_close]() {
        if (this[_autoClose] && typeof this[_fd] === 'number') {
            const fd = this[_fd];
            this[_fd] = undefined;
            fs.closeSync(fd);
            this.emit('close');
        }
    }
    [_write](buf) {
        // throw the original, but try to close if it fails
        let threw = true;
        try {
            this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
            threw = false;
        }
        finally {
            if (threw) {
                try {
                    this[_close]();
                }
                catch {
                    // ok error
                }
            }
        }
    }
}
//# sourceMappingURL=index.js.mapƳm}4:o]y]<#;AlObв+k.J_Y_ T  3TJ=Y|áaG_ Y:cUV&hH2bxl^E_OCv#n@WLExM} ;a%J
OeOi?'sPOE='P_WKꣶNG;BZت.(&hfSp;
#zX500ܒ|̈́In>k?i>[vPׂ(O:fN|#|wǷPշŐxx83Jla[mK jb[]W0SbCc7pݦoGfpT"LJ|T٭_+0 ;oe$4*qPaH*:<qꦧ70ƨ}R\,8.O)Z$IvAATOZTj:F"QTvCBq;C_Z`[@p=dOr;CZ[흝[?ҬLՊމ Hpj5?[]̜Ta,!G29_E6_5l{T@|qWkV0tAl0t#ȺGSxn<-
=1>u>>JE
*}LZ700󕾘Nvd>Ri@Ÿ`*G觵'*-B.ڤ~-lҰJ]xa:R5j'!<`7 Ŝ﹪alzT߇[Cd-Y]7!jĶ+8mma΂c*Uc9Ad\3+@%'+Wi=U^9.4F+輑p	,N30;6])GQĀ1X6Y%jÍ~F<OjD	V	LOQ$hߌxJ,x0ўqS2% mAZ$?|}Y:ǀ%F%ʶJ=0j"H˷]J3? YCm	Q4Մ7JT ETI~f)OA3OBBQ7ϢTĞRӼVʭJtR!XzZ=Zq$r<M/]\Z$NFUҾ<`|]dT.nId59BmilB
PÑ[/Ā\1_]u%2dMdFi4v`x6,:8y]<LrWuϓg-ڶ[tƚXyȍű@j_uMJl7E/C<`~z_7a&i{Wfɥ.Y@̣cz-VIM] t:`_GLrKOGK>ԍ0Z+`oxTmI66$Sj^ŗk;)F+ѐk=Jy]g|4=Py+[ιz[bowڳ~N,|VOf=5u~KEU.QkS=,]{BrL Z[0*x
<')vz]f_y3z3WyR	el7 S0S\v$Zjt׳nAb(r.//f2&Gy?~S:ۭu*e	pKWj>4AA0-"/f8
"-͂dlk}h&.*#J\z,OTN
-ցoBS1:eS 4U6u_k5Á6Wvڨ:?FYᎢss[F44ұ7"sǖCdeV(H|!\e^f`P	vE; vj\'M\Civx`i\765)LDg`!(Pi(]
pT.*!=x	I3}}9|NC`}Q܇&~ΧۺB)ˮ`@)MՀk-Pߴe`O-9Q"aiAfꨖ9Jƭ0FnܔQ/R^O5CaqրCx	mW/4dyK6kMjMq/}ՠx6&@M,zt,hXmm9F+a6خ9I?8x_^9:~뻓}ǿ;# vu}<aoѰf|Kq	Q|=l5~q]<0}^bK,HϮ؍l"uoik_Ul2@ۍ0w-[;۠#޷դ@j<.o9s0)gZ9mM~"!Qi7'hd;^ˀ(1G6{57\#n3S#-gX63Pkss^݀.I%5 "5llDe#MYnF`[duy}2#U^yZbt"F⼠SQ&raw#cxNVZLlᡅ=z6jΎ+>}bcx:peMXˮ$eDGU|!d+2FHD0T/7*`5{k5scQ o{vTM7'J>62ЛXdVb%	pcR.P xtCvP0dY]LnqVǦCw{Q=8u
4zjXk*Dkܴq^Ebk)}SwϘNt#< Y޾dmt2Eya}K2.vd%I>8?<}_^wiHp;='"ׇGCJo_!bxiD*]~+OwpWGSfyq|tx;<R2`}xgC'NtCcg'e)~t$)O9ׇC5϶ԯ'SK 
"9> 0[R/[[X	o3Ju,ygjdhK~>~Gکo?@|;~Ѫpx34dLjmeUh0<Dh#Q.~pFEYDQ](Fpec8gΘxAzWWf؋Q"bȎ҆ty&ʥD(+8WhN픏{`:.wښ/N*Hಫ>`pkjy]UMH&&yxOؽ)''мMUZ,E"7&t$9,1E$8@7%i!^aj:`kBKȹ:k閛NPt<-Lxw>ԤN;"'ªTNc)t	 `wXх9JuWĭ=ӌ]b':W,CK2n`1aw 8"+tArmI>Zj{EY|@u̟ܤH|HjVf!pсat!]=ܴ1YXʘ&8kt2%ҵ-K:O ņR/e:BEK)aQ̊CfC!:^ZXJHW&SfE7*A_`v^q=(_|TJTͪ)
f=kov-g
Fi[3[_D"c^ejȋ 0ȯйBdt2إ2]]"[gj2֯5QJ&+	膾וrsf.]e@ëKMQj
F3_n(j4C!00[7p6{,$q#/!ƿ3\9xfR1ާGh4.h[;f?Z[n@>Dѿ9u|/vm)Z	STRln<yr'ׯZtǳal66rC$HS(ׅF<w'l(.F
$_NlN;}ī ]X|IզkF%iIle*p}I݃پALםKyB?a:WEb3W[enH,*\d!3NƂa\sw=Aj5j .kRđïgpMB(M.@@+4̼YrP,9צVvOVY/412c|)	tR$;7ãP7Ƣr@tV9C$W#$\3!u%0$O߲Z6$}q9#W/(Xggn.x,e9p!YI'AP6yd~a4L'njĭ;&EG1(lCE}LMgQ2@cff@AS!hOLqЁ&0
Wj ]u>#]_^
4q&޼b	yF)Vl#䋩sxs:MΫ,E&{l`뽰ɝWx sV&"l
:.2\K?$Xbj$E-Y)a|*7ڤۍz!b5ڶ#-2'\X?^'<b}iޮ[iGB{΢.ZSmN[t6W5y^ym'Zыaa2:s= ^+ݩť
 H5	ӘȰVAj;tKiF'6fh[[rgm4ӱpwӭC.U' Rx\5aoϳkVTV}Lfw汽dP4!\ASg]duu|9ȷ$va#1cHvٟjsCu'q?nt:cO1>Ȏn?<dde"wd=Y5IʚAƚGrۻY*IͰiv>_gaY$Hƨ([˻K ܤZBVg#;eS qdwW<fPB @1AE}b(j-wՌ<^V![Ī8S}F]g:dLB?%/d~ޞD9J-PF%MZ3;G30J?|׷n=[d0yf\26n$giEglhK]{AOK󒴿"fRscxoع* 6NfT琉.zR
]|9윛vu+Nү~mhvc{5yr(˜Fc/|TFvF]
g@$в#y@USLRoi'+iE+8<UJȪjՠUP9}RJm^^-TzJﾥtyga@:acѩSl;L_`鿃O'xY*_~p W|k30GCOg&2Gtճs[1Aݱ<ٮealH#'wDSٔm#.gM/90 vKQǗxN&?n3XB婪>(nd14ihsyWvUv^X+W.\OG}'b}l^h7.6~ff }`h(w63ߊYB)	sRO_]ݮcR/߂'}kj`vT`LHn$0g,D0%4Y?)-l+51T̰:-[&,;}7!qI`i@ߋl^W7;2k=2[$ p˘P7ZƜG}{g[%#t-	l	.7ӂZEwn7cι=~LqӦBFjr'걗3Gl4GHt271&(uqNϚ('{[H.9VC!隀R7v©l3}~ӱ}(-(i."6ߘxv}i=O .sg}lU)wWƺ0";)RFjvoRքIbO(g#~Gٹ;ϣ=\yO(u^cٙ&sp[Yqy_dx[F,8֠m"}"]q?[`6M	^;b
%1UM9)j[M<)T4;LYʙ|,-WWLbY֟uZ515ϥaNw4R호;]_omDpiO؞.߬@2wjubIXEj)١)8mYTirb)\0qrؚg̶YGmt=Fyf{EjpP@
TnN&~fWri zF0`&BY_#[#΀j|iX"OFv;9=>Z+x0FfҟrF"(@);kenLAXkw\1=6C00#e?uMGx$s ~jlT*G=Vsw{)`p5ejzp͆v>)s^1
f( <r3JWVG5{o*uruBR4'NOt)id;TR^P'koE-afA^`#6X2(3V;IٮD
e4VzR ,5qIt)eFLԪyM76}TFFz~{!t(K!t,ģl½
pZq0:u]fԲys_ڽy$՘і=֦~֦~oFsvogw9ΙLL7W
9(9mԩ=BÅzK.p<ըo-zPH[2*KBD巂Z2<ͣ-c׹ )7-mgRp	n%>|&hc(m9ZBvvGrhP=,1~Z!VޛW,Zg4)2ψpQqg$vy2ߤ*ǵ`E!=d0]Z<<[(@ҩNf:BW/wa>lP$}/v)Pf++^[K}Ly+S~orV7yVM=Sh߈wvnxg%;Ѳٴnh~EQ:<p-h;DGg*Km4?[89H4oM<=>z3<+c5g!F{:Ccic:)qll7zvqg\4:S&
16;`PGM!o]78qH{8G3oA0s 7f.H29nOQ9$Y)\ttrj9@v +@Mq@*0(Q0uɻ>ø[SWKp/sftJ0ً=8҆/J/s0{y].>\-v}-u}<"$]cM]@9~@67tַ=k|5&ώ#K;F:t*"Ahw{*-CRh筨n`cc:PgԃFcNLtc{͸hC#=h,*.EP-wwl+#.Ţoa{j&abL0&̈́	01na7&̈́q3ab8ܚfIa+ab<r+*ab8qDtLU}g01N*L018J\le01qYqDڛ8qq&fY	qV
h8K8O=/L9abo
ÂE/	01^6LLxA^0I`PTA&&y7&&\&abt^&F<abĸ+qW
nqpy	ab><V˦/&$Lhm	ZrOq&LzzGYlX/V{_?>(rN|w3).`Uoԛ 4Rn4
Y̳XQ;/[aȝR/,W=	h+3XJ 8ZbQEs*ݩw꿢CTqrCV9@3\Bs ܤx`T$y3#4&ɷ//R84@ bi6#jM?E;ym6_1w5ʼ3Aɵ

	Kmb-@Hρ2PBv]%:g7@!'܈]^ԙ_DAqǙ#ϙ̦.?B'w?]S9\7<$M`xt2dDz7o5^J­luL}V"*a/hNMG>Ƶ[Cv/,"\F}Ke/qcn\7﫜[&M`ܟtMy1Ll(29*ؼ{ӱo^^LIEr"E`nkM:4#?V"\}MP20ս;_y{8oh	Sxa#Rv}q\G_:^Vyd;}%#L<zce^_7P;9p	M7!pﻘr}A
E+`ߒjЗOa!StUߋ+g y`',)M,RTAN$maWn߁Ol\0$p/꩔Iϫ:1(3 $>`%KNoss[	?l*}T\÷au`Olv6q"//z	[<].|ڟ*mz.oԷk	G3=bZ/O%:1Oayl-cHdQ101̥tHM=EBݗ&5jVw5㻚^I79>ޟO~]W&S8 +Sa^:wuXH,4siBom6w3!S7r
ڪb1>1<{BȪO+ny~~>+
{JT2s{:u`+ߎ5nf>U?+}dVYo'*{$V6vS?1_TOVWq>>b*%_c$?'mW&*>OaFp]$|*0V'XVGoi?ҏOw&L˹L,A:>4a)+Sb}}YU|+x[ RK6c*ET[8U(YbUqK._})DuoʺǒT>	mLU}aJ]5#V_FU[=Th[9ďMԿ?W>VMjNlN( c<m$:n~%ߟ}/A)aV-m%rŰ2B'ZOwB._f0b[fݿGTAx`8H5~qFZ[K2ё\5Au"^/JlI9IdY	TD.zYe/Krǹz$NdCֹupڕ:[	\rq/ԃeLAHfȺYu"ê+lgӃL~cOf^~ua}B
>}0Y~4!.}_	'
CMڟYj{Ha5}'Mmօ8z/z&Mwr 3%ᄟǬ0c(1ɯE_	AIo3ȿ~Rc)ʬ/'fҞ%Oˡ⩀W˛)6Mx:@ЃiJ~/,NĻM\p	oeqw`s%A*7TP(`{y #5dn3YB8ٻMC'WRC[IPKrCCcp:FL(.ֺ_ĉ.N*W6dlpeT$gQ9I맪Őҕ>BY#T@LSB#?Kyh>wGr{^/]T~F;Qzk6HB}]+]%^W*X	x46	ϔ᭫p~#O73nZbdJn2UgXٟTtPq+HdyCmZJ-O#>`#̪yB.2pe`!XTX4:2FYhr_U"vV+d׼]鿿e@,-)
%ڿs]6rrwCQQV3%P.sfF7֬1q۪R!2ȿ.԰Y2~rP je~\Yj_wR4m+Z˅_ӓ-UIt%*J$ 	#	3]e2~OÏ:lvIѷ/ ѝAy]f*W,|J_:KSxm2IM9ASʰ?OJ9Y;eƂ(*N1k*"W3?hᗜWe؃a*a:#4{<hG7e9p.Zd-x&~ZDbCT%Z!MRָ`<phI@4c$i]ULdnBeZV_1	8Bj܅Gz{H'XF>9$$8ن|z!eiE=K
<b,wq\&C>C~
?H!˒TI>Oj~Rީ~05=do4u)b_9MH8
=IQ}*H3;]1Z4C.{hϔsnJ)a?+] ?EtZ2Li!Dx-LV,Gx:U<  g|Dt丘Kt(O[N;/h}-|H$72%YJ%
CAmZJE x9-cرh(CPs)^&ps4Bh@IXn56E6b,7
fMF<	+WĪΤ/2za>id⿖d M<._ӤI>d=LOv&gx Fŵ