var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var mocha$2 = {exports: {}};

var mocha$1 = mocha$2.exports;

var hasRequiredMocha;

function requireMocha () {
	if (hasRequiredMocha) return mocha$2.exports;
	hasRequiredMocha = 1;
	(function (module, exports) {
		// mocha@11.2.2 in javascript ES2018
		(function (global, factory) {
		  module.exports = factory() ;
		})(mocha$1, (function () {
		  var global$2 = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal :
		    typeof self !== "undefined" ? self :
		    typeof window !== "undefined" ? window : {});

		  var global$1 = (typeof global$2 !== "undefined" ? global$2 :
		              typeof self !== "undefined" ? self :
		              typeof window !== "undefined" ? window : {});

		  // shim for using process in browser
		  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

		  function defaultSetTimout$1() {
		      throw new Error('setTimeout has not been defined');
		  }
		  function defaultClearTimeout$1 () {
		      throw new Error('clearTimeout has not been defined');
		  }
		  var cachedSetTimeout$1 = defaultSetTimout$1;
		  var cachedClearTimeout$1 = defaultClearTimeout$1;
		  if (typeof global$1.setTimeout === 'function') {
		      cachedSetTimeout$1 = setTimeout;
		  }
		  if (typeof global$1.clearTimeout === 'function') {
		      cachedClearTimeout$1 = clearTimeout;
		  }

		  function runTimeout$1(fun) {
		      if (cachedSetTimeout$1 === setTimeout) {
		          //normal enviroments in sane situations
		          return setTimeout(fun, 0);
		      }
		      // if setTimeout wasn't available but was latter defined
		      if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout) {
		          cachedSetTimeout$1 = setTimeout;
		          return setTimeout(fun, 0);
		      }
		      try {
		          // when when somebody has screwed with setTimeout but no I.E. maddness
		          return cachedSetTimeout$1(fun, 0);
		      } catch(e){
		          try {
		              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
		              return cachedSetTimeout$1.call(null, fun, 0);
		          } catch(e){
		              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
		              return cachedSetTimeout$1.call(this, fun, 0);
		          }
		      }


		  }
		  function runClearTimeout$1(marker) {
		      if (cachedClearTimeout$1 === clearTimeout) {
		          //normal enviroments in sane situations
		          return clearTimeout(marker);
		      }
		      // if clearTimeout wasn't available but was latter defined
		      if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout) {
		          cachedClearTimeout$1 = clearTimeout;
		          return clearTimeout(marker);
		      }
		      try {
		          // when when somebody has screwed with setTimeout but no I.E. maddness
		          return cachedClearTimeout$1(marker);
		      } catch (e){
		          try {
		              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
		              return cachedClearTimeout$1.call(null, marker);
		          } catch (e){
		              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
		              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
		              return cachedClearTimeout$1.call(this, marker);
		          }
		      }



		  }
		  var queue$1 = [];
		  var draining$1 = false;
		  var currentQueue$1;
		  var queueIndex$1 = -1;

		  function cleanUpNextTick$1() {
		      if (!draining$1 || !currentQueue$1) {
		          return;
		      }
		      draining$1 = false;
		      if (currentQueue$1.length) {
		          queue$1 = currentQueue$1.concat(queue$1);
		      } else {
		          queueIndex$1 = -1;
		      }
		      if (queue$1.length) {
		          drainQueue$1();
		      }
		  }

		  function drainQueue$1() {
		      if (draining$1) {
		          return;
		      }
		      var timeout = runTimeout$1(cleanUpNextTick$1);
		      draining$1 = true;

		      var len = queue$1.length;
		      while(len) {
		          currentQueue$1 = queue$1;
		          queue$1 = [];
		          while (++queueIndex$1 < len) {
		              if (currentQueue$1) {
		                  currentQueue$1[queueIndex$1].run();
		              }
		          }
		          queueIndex$1 = -1;
		          len = queue$1.length;
		      }
		      currentQueue$1 = null;
		      draining$1 = false;
		      runClearTimeout$1(timeout);
		  }
		  function nextTick$1(fun) {
		      var args = new Array(arguments.length - 1);
		      if (arguments.length > 1) {
		          for (var i = 1; i < arguments.length; i++) {
		              args[i - 1] = arguments[i];
		          }
		      }
		      queue$1.push(new Item$1(fun, args));
		      if (queue$1.length === 1 && !draining$1) {
		          runTimeout$1(drainQueue$1);
		      }
		  }
		  // v8 likes predictible objects
		  function Item$1(fun, array) {
		      this.fun = fun;
		      this.array = array;
		  }
		  Item$1.prototype.run = function () {
		      this.fun.apply(null, this.array);
		  };
		  var title$1 = 'browser';
		  var platform$1 = 'browser';
		  var browser$4 = true;
		  var env$1 = {};
		  var argv$1 = [];
		  var version$2 = ''; // empty string to avoid regexp issues
		  var versions$1 = {};
		  var release$1 = {};
		  var config$1 = {};

		  function noop$1() {}

		  var on$1 = noop$1;
		  var addListener$1 = noop$1;
		  var once$1 = noop$1;
		  var off$1 = noop$1;
		  var removeListener$1 = noop$1;
		  var removeAllListeners$1 = noop$1;
		  var emit$1 = noop$1;

		  function binding$1(name) {
		      throw new Error('process.binding is not supported');
		  }

		  function cwd$1 () { return '/' }
		  function chdir$1 (dir) {
		      throw new Error('process.chdir is not supported');
		  }function umask$1() { return 0; }

		  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
		  var performance$1 = global$1.performance || {};
		  var performanceNow$1 =
		    performance$1.now        ||
		    performance$1.mozNow     ||
		    performance$1.msNow      ||
		    performance$1.oNow       ||
		    performance$1.webkitNow  ||
		    function(){ return (new Date()).getTime() };

		  // generate timestamp or delta
		  // see http://nodejs.org/api/process.html#process_process_hrtime
		  function hrtime$1(previousTimestamp){
		    var clocktime = performanceNow$1.call(performance$1)*1e-3;
		    var seconds = Math.floor(clocktime);
		    var nanoseconds = Math.floor((clocktime%1)*1e9);
		    if (previousTimestamp) {
		      seconds = seconds - previousTimestamp[0];
		      nanoseconds = nanoseconds - previousTimestamp[1];
		      if (nanoseconds<0) {
		        seconds--;
		        nanoseconds += 1e9;
		      }
		    }
		    return [seconds,nanoseconds]
		  }

		  var startTime$1 = new Date();
		  function uptime$1() {
		    var currentTime = new Date();
		    var dif = currentTime - startTime$1;
		    return dif / 1000;
		  }

		  var process = {
		    nextTick: nextTick$1,
		    title: title$1,
		    browser: browser$4,
		    env: env$1,
		    argv: argv$1,
		    version: version$2,
		    versions: versions$1,
		    on: on$1,
		    addListener: addListener$1,
		    once: once$1,
		    off: off$1,
		    removeListener: removeListener$1,
		    removeAllListeners: removeAllListeners$1,
		    emit: emit$1,
		    binding: binding$1,
		    cwd: cwd$1,
		    chdir: chdir$1,
		    umask: umask$1,
		    hrtime: hrtime$1,
		    platform: platform$1,
		    release: release$1,
		    config: config$1,
		    uptime: uptime$1
		  };

		  var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

		  function getAugmentedNamespace(n) {
		  	if (n.__esModule) return n;
		  	var a = Object.defineProperty({}, '__esModule', {value: true});
		  	Object.keys(n).forEach(function (k) {
		  		var d = Object.getOwnPropertyDescriptor(n, k);
		  		Object.defineProperty(a, k, d.get ? d : {
		  			enumerable: true,
		  			get: function () {
		  				return n[k];
		  			}
		  		});
		  	});
		  	return a;
	